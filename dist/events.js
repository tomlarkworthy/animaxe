var Ax = require("./animaxe");
/**
 * Objects of this type are passed through the tick pipeline, and encapsulate potentially many concurrent system events
 * originating from the canvas DOM. These have to be intepreted by UI components to see if they hit
 */
var Events = (function () {
    function Events() {
        this.mousedowns = [];
        this.mouseups = [];
        this.mousemoves = [];
        this.mouseenters = [];
        this.mouseleaves = [];
    }
    //onmouseover: Ax.Point[] = []; to implement these we need to think about heirarchy in components
    //onmouseout: Ax.Point[] = [];
    /**
     * clear all the events, done by animator at the end of a tick
     */
    Events.prototype.clear = function () {
        this.mousedowns = [];
        this.mouseups = [];
        this.mousemoves = [];
        this.mouseenters = [];
        this.mouseleaves = [];
    };
    return Events;
})();
exports.Events = Events;
var ComponentMouseEvents = (function () {
    function ComponentMouseEvents(source) {
        this.source = source;
        this.mousedown = new Rx.Subject();
        this.mouseup = new Rx.Subject();
        this.mousemove = new Rx.Subject();
        this.mouseenter = new Rx.Subject();
        this.mouseleave = new Rx.Subject();
    }
    return ComponentMouseEvents;
})();
exports.ComponentMouseEvents = ComponentMouseEvents;
/**
 * returns an animation that can be pipelined after a path, which used canvas isPointInPath to detect if a mouse event has
 * occured over the source animation
 */
function ComponentMouseEventHandler(events) {
    return Ax.draw(function () {
        var mouseIsOver = false;
        return function (tick) {
            function processSystemMouseEvents(sourceEvents, componentEventStream) {
                sourceEvents.forEach(function (evt) {
                    if (componentEventStream.hasObservers() && tick.ctx.isPointInPath(evt[0], evt[1])) {
                        // we have to figure out the global position of this component, so the x and y
                        // have to go backward through the transform matrix
                        // ^ todo
                        console.log("HIT", evt, componentEventStream);
                        var localEvent = new AxMouseEvent(events.source, /*todo*/ [0, 0], evt);
                        componentEventStream.onNext(localEvent);
                    }
                });
            }
            function processSystemMouseMoveEvents(sourceMoveEvents, mousemoveStream, mouseenterStream, mouseleaveStream) {
                sourceMoveEvents.forEach(function (evt) {
                    if (mousemoveStream.hasObservers() || mouseenterStream.hasObservers() || mouseleaveStream.hasObservers()) {
                        var pointInPath = tick.ctx.isPointInPath(evt[0], evt[1]);
                        var localEvent = new AxMouseEvent(events.source, /*todo*/ [0, 0], evt);
                        if (mouseenterStream.hasObservers() && pointInPath && !mouseIsOver) {
                            mouseenterStream.onNext(localEvent);
                        }
                        if (mousemoveStream.hasObservers() && pointInPath) {
                            mousemoveStream.onNext(localEvent);
                        }
                        if (mouseleaveStream.hasObservers() && !pointInPath && mouseIsOver) {
                            mouseleaveStream.onNext(localEvent);
                        }
                        mouseIsOver = pointInPath;
                    }
                });
            }
            processSystemMouseEvents(tick.events.mousedowns, events.mousedown);
            processSystemMouseEvents(tick.events.mouseups, events.mouseup);
            processSystemMouseMoveEvents(tick.events.mousemoves, events.mousemove, events.mouseenter, events.mouseleave);
        };
    });
}
exports.ComponentMouseEventHandler = ComponentMouseEventHandler;
var AxMouseEvent = (function () {
    function AxMouseEvent(source, localPos, globalPos) {
        this.source = source;
        this.localPos = localPos;
        this.globalPos = globalPos;
    }
    return AxMouseEvent;
})();
exports.AxMouseEvent = AxMouseEvent;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV2ZW50cy50cyJdLCJuYW1lcyI6WyJFdmVudHMiLCJFdmVudHMuY29uc3RydWN0b3IiLCJFdmVudHMuY2xlYXIiLCJDb21wb25lbnRNb3VzZUV2ZW50cyIsIkNvbXBvbmVudE1vdXNlRXZlbnRzLmNvbnN0cnVjdG9yIiwiQ29tcG9uZW50TW91c2VFdmVudEhhbmRsZXIiLCJDb21wb25lbnRNb3VzZUV2ZW50SGFuZGxlci5wcm9jZXNzU3lzdGVtTW91c2VFdmVudHMiLCJDb21wb25lbnRNb3VzZUV2ZW50SGFuZGxlci5wcm9jZXNzU3lzdGVtTW91c2VNb3ZlRXZlbnRzIiwiQXhNb3VzZUV2ZW50IiwiQXhNb3VzZUV2ZW50LmNvbnN0cnVjdG9yIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFPLEVBQUUsV0FBVyxXQUFXLENBQUMsQ0FBQztBQUlqQzs7O0dBR0c7QUFDSDtJQUFBQTtRQUNJQyxlQUFVQSxHQUFzQkEsRUFBRUEsQ0FBQ0E7UUFDbkNBLGFBQVFBLEdBQXdCQSxFQUFFQSxDQUFDQTtRQUNuQ0EsZUFBVUEsR0FBc0JBLEVBQUVBLENBQUNBO1FBQ25DQSxnQkFBV0EsR0FBc0JBLEVBQUVBLENBQUNBO1FBQ3BDQSxnQkFBV0EsR0FBc0JBLEVBQUVBLENBQUNBO0lBY3hDQSxDQUFDQTtJQWJHRCxpR0FBaUdBO0lBQ2pHQSw4QkFBOEJBO0lBRTlCQTs7T0FFR0E7SUFDSEEsc0JBQUtBLEdBQUxBO1FBQ0lFLElBQUlBLENBQUNBLFVBQVVBLEdBQUdBLEVBQUVBLENBQUNBO1FBQ3JCQSxJQUFJQSxDQUFDQSxRQUFRQSxHQUFLQSxFQUFFQSxDQUFDQTtRQUNyQkEsSUFBSUEsQ0FBQ0EsVUFBVUEsR0FBR0EsRUFBRUEsQ0FBQ0E7UUFDckJBLElBQUlBLENBQUNBLFdBQVdBLEdBQUdBLEVBQUVBLENBQUNBO1FBQ3RCQSxJQUFJQSxDQUFDQSxXQUFXQSxHQUFHQSxFQUFFQSxDQUFDQTtJQUMxQkEsQ0FBQ0E7SUFDTEYsYUFBQ0E7QUFBREEsQ0FuQkEsQUFtQkNBLElB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TkEsTUFBTUEsQ0FBS0E7UUFBU0EsYUFBUUEsR0FBUkEsUUFBUUEsQ0FBVUE7UUFBU0EsY0FBU0EsR0FBVEEsU0FBU0EsQ0FBVUE7SUFBR0EsQ0FBQ0E7SUFDN0ZELG1CQUFDQTtBQUFEQSxDQUZBLEFBRUNBLElBQUE7QUFGWSxvQkFBWSxlQUV4QixDQUFBIiwiZmlsZSI6ImV2ZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBeCA9IHJlcXVpcmUoXCIuL2FuaW1heGVcIik7XG5cblxuZXhwb3J0IHR5cGUgU3lzdGVtTW91c2VFdmVudHMgPSBBeC5Qb2ludFtdO1xuLyoqXG4gKiBPYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgcGFzc2VkIHRocm91Z2ggdGhlIHRpY2sgcGlwZWxpbmUsIGFuZCBlbmNhcHN1bGF0ZSBwb3RlbnRpYWxseSBtYW55IGNvbmN1cnJlbnQgc3lzdGVtIGV2ZW50c1xuICogb3JpZ2luYXRpbmcgZnJvbSB0aGUgY2FudmFzIERPTS4gVGhlc2UgaGF2ZSB0byBiZSBpbnRlcHJldGVkIGJ5IFVJIGNvbXBvbmVudHMgdG8gc2VlIGlmIHRoZXkgaGl0XG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudHMge1xuICAgIG1vdXNlZG93bnM6IFN5c3RlbU1vdXNlRXZlbnRzID0gW107XG4gICAgbW91c2V1cHM6ICAgU3lzdGVtTW91c2VFdmVudHMgPSBbXTtcbiAgICBtb3VzZW1vdmVzOiBTeXN0ZW1Nb3VzZUV2ZW50cyA9IFtdO1xuICAgIG1vdXNlZW50ZXJzOiBTeXN0ZW1Nb3VzZUV2ZW50cyA9IFtdO1xuICAgIG1vdXNlbGVhdmVzOiBTeXN0ZW1Nb3VzZUV2ZW50cyA9IFtdO1xuICAgIC8vb25tb3VzZW92ZXI6IEF4LlBvaW50W10gPSBbXTsgdG8gaW1wbGVtZW50IHRoZXNlIHdlIG5lZWQgdG8gdGhpbmsgYWJvdXQgaGVpcmFyY2h5IGluIGNvbXBvbmVudHNcbiAgICAvL29ubW91c2VvdXQ6IEF4LlBvaW50W10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIGNsZWFyIGFsbCB0aGUgZXZlbnRzLCBkb25lIGJ5IGFuaW1hdG9yIGF0IHRoZSBlbmQgb2YgYSB0aWNrXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubW91c2Vkb3ducyA9IFtdO1xuICAgICAgICB0aGlzLm1vdXNldXBzICAgPSBbXTtcbiAgICAgICAgdGhpcy5tb3VzZW1vdmVzID0gW107XG4gICAgICAgIHRoaXMubW91c2VlbnRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tb3VzZWxlYXZlcyA9IFtdO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudE1vdXNlRXZlbnRzIHtcbiAgICBtb3VzZWRvd24gICAgPSBuZXcgUnguU3ViamVjdDxBeE1vdXNlRXZlbnQ+KCk7XG4gICAgbW91c2V1cCAgICAgID0gbmV3IFJ4LlN1YmplY3Q8QXhNb3VzZUV2ZW50PigpO1xuICAgIG1vdXNlbW92ZSAgICA9IG5ldyBSeC5TdWJqZWN0PEF4TW91c2VFdmVudD4oKTtcbiAgICBtb3VzZWVudGVyICAgPSBuZXcgUnguU3ViamVjdDxBeE1vdXNlRXZlbnQ+KCk7XG4gICAgbW91c2VsZWF2ZSAgID0gbmV3IFJ4LlN1YmplY3Q8QXhNb3VzZUV2ZW50PigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogYW55KSB7fVxufVxuXG4vKipcbiAqIHJldHVybnMgYW4gYW5pbWF0aW9uIHRoYXQgY2FuIGJlIHBpcGVsaW5lZCBhZnRlciBhIHBhdGgsIHdoaWNoIHVzZWQgY2FudmFzIGlzUG9pbnRJblBhdGggdG8gZGV0ZWN0IGlmIGEgbW91c2UgZXZlbnQgaGFzXG4gKiBvY2N1cmVkIG92ZXIgdGhlIHNvdXJjZSBhbmltYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudE1vdXNlRXZlbnRIYW5kbGVyKGV2ZW50czogQ29tcG9uZW50TW91c2VFdmVudHMpOiBBeC5BbmltYXRpb24ge1xuICAgIHJldHVybiBBeC5kcmF3KFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgbW91c2VJc092ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAodGljazogQXguVGljaykgPT4ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTeXN0ZW1Nb3VzZUV2ZW50cyhcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRXZlbnRzOiBTeXN0ZW1Nb3VzZUV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RXZlbnRTdHJlYW06IFJ4LlN1YmplY3Q8QXhNb3VzZUV2ZW50PlxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VFdmVudHMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgICAgICAgIChldnQ6IEF4LlBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEV2ZW50U3RyZWFtLmhhc09ic2VydmVycygpICYmIHRpY2suY3R4LmlzUG9pbnRJblBhdGgoZXZ0WzBdLCBldnRbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gZmlndXJlIG91dCB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoaXMgY29tcG9uZW50LCBzbyB0aGUgeCBhbmQgeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIGdvIGJhY2t3YXJkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXiB0b2RvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSElUXCIsIGV2dCwgY29tcG9uZW50RXZlbnRTdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxFdmVudCA9IG5ldyBBeE1vdXNlRXZlbnQoZXZlbnRzLnNvdXJjZSwgLyp0b2RvKi9bMCwwXSwgZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RXZlbnRTdHJlYW0ub25OZXh0KGxvY2FsRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTeXN0ZW1Nb3VzZU1vdmVFdmVudHMoXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1vdmVFdmVudHM6IFN5c3RlbU1vdXNlRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBtb3VzZW1vdmVTdHJlYW06IFJ4LlN1YmplY3Q8QXhNb3VzZUV2ZW50PixcbiAgICAgICAgICAgICAgICAgICAgbW91c2VlbnRlclN0cmVhbTogUnguU3ViamVjdDxBeE1vdXNlRXZlbnQ+LFxuICAgICAgICAgICAgICAgICAgICBtb3VzZWxlYXZlU3RyZWFtOiBSeC5TdWJqZWN0PEF4TW91c2VFdmVudD5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTW92ZUV2ZW50cy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGV2dDogQXguUG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2Vtb3ZlU3RyZWFtLmhhc09ic2VydmVycygpIHx8IG1vdXNlZW50ZXJTdHJlYW0uaGFzT2JzZXJ2ZXJzKCkgfHwgbW91c2VsZWF2ZVN0cmVhbS5oYXNPYnNlcnZlcnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRJblBhdGggPSB0aWNrLmN0eC5pc1BvaW50SW5QYXRoKGV2dFswXSwgZXZ0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsRXZlbnQgPSBuZXcgQXhNb3VzZUV2ZW50KGV2ZW50cy5zb3VyY2UsIC8qdG9kbyovWzAsIDBdLCBldnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlZW50ZXJTdHJlYW0uaGFzT2JzZXJ2ZXJzKCkgJiYgcG9pbnRJblBhdGggJiYgIW1vdXNlSXNPdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZWVudGVyU3RyZWFtLm9uTmV4dChsb2NhbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2Vtb3ZlU3RyZWFtLmhhc09ic2VydmVycygpICYmIHBvaW50SW5QYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZW1vdmVTdHJlYW0ub25OZXh0KGxvY2FsRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlbGVhdmVTdHJlYW0uaGFzT2JzZXJ2ZXJzKCkgJiYgIXBvaW50SW5QYXRoICYmIG1vdXNlSXNPdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZWxlYXZlU3RyZWFtLm9uTmV4dChsb2NhbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlSXNPdmVyID0gcG9pbnRJblBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1N5c3RlbU1vdXNlRXZlbnRzKHRpY2suZXZlbnRzLm1vdXNlZG93bnMsIGV2ZW50cy5tb3VzZWRvd24pO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NTeXN0ZW1Nb3VzZUV2ZW50cyh0aWNrLmV2ZW50cy5tb3VzZXVwcywgZXZlbnRzLm1vdXNldXApO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NTeXN0ZW1Nb3VzZU1vdmVFdmVudHModGljay5ldmVudHMubW91c2Vtb3ZlcywgZXZlbnRzLm1vdXNlbW92ZSwgZXZlbnRzLm1vdXNlZW50ZXIsIGV2ZW50cy5tb3VzZWxlYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIClcbn1cblxuZXhwb3J0IGNsYXNzIEF4TW91c2VFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogYW55LCBwdWJsaWMgbG9jYWxQb3M6IEF4LlBvaW50LCBwdWJsaWMgZ2xvYmFsUG9zOiBBeC5Qb2ludCkge31cbn0iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
