// todo BUG TODO LIST

// Features

// Glow
    // different distance exponents are interesting
    // think about alpha over existing backgrounds
    // fix effiency bounds

// Reflection
// L systems (fold?)
// simulate a lazer show, XY parametric functions (Lissajous curves), intergrate with ODE solver

// Deployment
//   - <script src=animaxe.js> ... var Ax = Ax() ; ... new Ax.Animator();
// REALITY:
// - we follow RxJS conventions, which means commonjs external modules
// - we need Ax to depend on Rx. Which suggests importing it as a module, however that does not work in browser.
// - External module typescript system a must, therefore webpack for browser usage
// - webpack standalone example works
// see http://codepen.io/tomlarkworthy/pen/jbmVWO


// Why we went with code pen
// - code pen sucks for syntax errors, and you have to declare the Ax module inline (though at least you can do this at the bottom)
// - however, even with strong compilation, the errors are not highlighted inline and are confusing
// - Playground-on-ace https://github.com/hi104/typescript-playground-on-ace does GREAT error reporting, but no sharing code :/
// - JSBin doesn't propogate type errors at all and is totally shit
// - JSFiddle doesn't read typescript
// - FORGET MAKING A TYPESCRIPT EDITOR, the raw JS is basically the same, and the definition file describes the API somewhat.
// - fix all examples with codepen
// TODO packaging
- each helper library includes the main animaxe library, we need to make those smaller using external modules
- I don't like the webpack names have to be different
- Test npm integration
// ES6 modules? Can we make the packaging equivalent? Maybe jsut a browser & and node.js directory structure?


// Engineering

// figure out why example3 cannot have move than 1000 particles without a stack overflow
// fix test randomness with a random seed (seed random with animation seed?)
// replace parralel with its own internal animator OR make parallel the only option
// change order of playExample parameters

* refactor
// (done) Parameter to go in own module, params chained to make value read left to right
// (done) Parameter.rnd().first()        // maybe we should just make it pure by seeding the rnd by epock or tree position?
// (done) Parameter.rnd().map(x => x*x)
// (done) Ax.Parameter() for construction
// (done) Make methods chain as an alternative to wrapping, e.g. Ax.move(...).velocity(...)
// (done) add .pipe(animation) so users can chain themselves
// (partial) align names of methods with canvas context name, e.g. fillStyle(Color)
     - finish that API!
     - withinClip, withinTx, (done) withinPath
     - createLinearGradient, createPattern(), createRadialGradient(), addColorStop(), isPointInPath(), measureText(), drawImage()
     - save() restore()
// maybe put context methods in their own namespace if possible? (long term goal)
// consider hiding time from Animation? It should only be used in params
// simplifying closure situation? Maybe handle params internally through DI?
// the tick in animator is ugly

// Marketing

// API documentation
Improve README.me
- What is Animaxe?
  - a better canvas API
  - a reactive animation library, with FRP influences
  - an experiment in library design
- method chaining
- lifecycle
- making your own Animation
- making your own Parameters
- overriding the prototype
- using .pipe()
- example of switching from the canvas API to a linear chain
- how a new chain resets the context
- using https://github.com/anthonydugois/svg-path-builder

// website
// - npm
// - hosting

// Code pen example
UI controls!
 - need to attach mouse events, to paths tests i.e. isPointInPath().
 - isPoint is tested when the path is drawn, so you have to know your going to test for a point before the animation loop draws, then do the test inline with the drawing
 - OR you just to the test on a line without doing a stroke.
 - lets think about the ideal API, :-

 We want to be able to package up a UI control. It has various animation states. An internal state. Its state can be changed with streams into it (e.g. its label)
, also its internal state(s) are watchable with more streams. It also has hot spots for mouse clicks. So it has
Different logical input and output streams.
 - position (input and output)
 - programatic click (input)
 - mouse events
 - relative mouse position (output)
A number animations and transitions. (button down)
Maybe some config (e.g. feature disable, max/min value)
Default mouse behaviour.
UI events like mouse should be consumed leaf upwards, with the option of propogating events or not. This is the opposite way round things are drawn.

- Conclusion, UI components are their own bundle of resources, including animations.
- We need access in the animation pipeline for the collision stuff though, but the UI can handle that itself

// all sliders vertical, but you can transform using graphics?
LinearSlider extends Animation
- initial value, min/max value
- background animation
- knob animation
- listens for mouse drag on knob
- UI visual appearance should be Rx too! Parameter based sizes

^^ the UI model doesn't really matter, we should be able to add different abstractions later
   the important bit is the mouse interceptor for path, and a way to stream notifications out.


// IDEAS

// PacMan
// what about a different way of making glow?
// render luminecence into a texture and then color based on distance from lightsource
// mouse input, tailing glow (remember to tween between rapid movements)
// offscreen rendering an playback
// sin wave, randomized
// GUI components, responsive, bootstrap
// get data out by tapping into flow (intercept(Subject passback))
// SVG import

