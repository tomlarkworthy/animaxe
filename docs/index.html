<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Animaxe</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
	<script src="assets/js/modernizr.js"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Animaxe</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Animaxe</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="animaxe-composable-animation-library">Animaxe, Composable Animation Library</h1>
				<p>Maybe I should explain my motivation, I like procedural graphics, graphics drawn by code.
					But fiddling with parameters in a compile-execute cycle is slow and does not get the best artistic results.
				So I want a graphical system that allows me to:</p>
				<ul>
					<li>Alter the generation code dynamically and see the results immediately (that&#39;s why I put the examples on Codepen)</li>
					<li>Fiddle with the animation meta parameters live (that&#39;s what the FRP-like bit helps with)</li>
				</ul>
				<p>So the aim of Animaxe is to be a few things:</p>
				<ul>
					<li>Make it easy to create animations that are composable. </li>
					<li>Be a nicer API for the Canvas drawing API</li>
					<li>Be reactive, every parameter to every animation primitive should be alterable at any time</li>
					<li>Be functional, a lot of inspiration is drawn from Functional Reactive Programming, although the intention is not to be too pure</li>
					<li>Be efficient</li>
					<li>Be typed using Typescript</li>
				</ul>
				<p>Now you can compose animations <em>functionally</em>. Ideal for procedural and <em>interactive</em> animations.</p>
				<p>Its still very early on this project, the basic building blocks are not complete, and the repository layout is not useful for libraries to link to. However, the following is a proof-of-concept for the API feel. Maybe you want to contribute?</p>
				<h2 id="being-a-nicer-canvas-api">Being a nicer Canvas API</h2>
				<p>Instead of the procedural style of drawing that the Canvas API uses, we chain. So instead of:</p>
				<pre><code>ctx.fillStyle = <span class="hljs-string">"red"</span>;
ctx.translate(<span class="hljs-number">30</span>, <span class="hljs-number">45</span>);
ctx.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
</code></pre><p>In Animaxe we use the Ax module as the entrace to an animation chain. We use the same identifiers as the Canvas API, so it becomes</p>
				<pre><code>Ax.fillStyle(<span class="hljs-string">"red"</span>)
  .translate([<span class="hljs-number">30</span>, <span class="hljs-number">45</span>])
  .fillRect([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]);
</code></pre><h2 id="being-reactive">Being reactive</h2>
				<p>It&#39;s worth noting almost every argument in Animaxe can be a literal, like in the example above, OR, it can be a dynamic time varying value.
				The Parameter module is the entrance to time varying functions, which can also be chained together with the normal functional primitives.</p>
				<p>For example, a fading in an out example:</p>
				<pre><code>Ax.fillStyle(Parameter.rgba(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, Parameter.<span class="hljs-built_in">sin</span>(Parameter.t())))
  .translate(Parameter.point(<span class="hljs-number">30</span>, Parameter.<span class="hljs-built_in">sin</span>(<span class="hljs-number">30</span>).<span class="hljs-built_in">map</span>(x =&gt; x * <span class="hljs-number">50</span>)))
  .fillRect([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]);
</code></pre><h2 id="the-animation-life-lifecycle-and-why-this-is-not-like-elm-">The animation life lifecycle (and why this is not like Elm)</h2>
				<p>Traditional Functional Reactive Programming (FRP), e.g. Fran, Elm, is built using Signals.
					A Signal is a static stream of data, there is no meaningful &#39;end&#39; to the data stream.
					This contrasts with reactive extentions&#39;, Observable, where each stream, in addition to sending data, also has an explicit &#39;completed&#39; semantic.
				<em>Reactive Extension streams have the potential to have an end</em>.</p>
				<p>FRP has some amazing features, history rewinding, complete abstraction away from &quot;updating&quot; the dependency graph, etc.
					However, these features come at the great cost of generally not being able to dynamically add and remove signals in a running application.
				Signal&#39;s in FRP are <em>static</em>. (In Elm this is the explicit exclusion of Signals of Signals, in FRP theory you can do this, but it eats all your memory) </p>
				<p>Reactive Extensions was developed independently from traditional FRP, on the observation that the pull based iterator had a dual in the observer pattern.
					The rich composable API you can build around iterators, also exist for push based stream.
				It&#39;s amazing that FRP and Rx have any conceptual overlap, given their independent roots and derivations.</p>
				<p>Now consider you want to build an graphical application. You want it to look cool (e.g. its a game),
					so some of the elements are animations. You want the animations to be chainable, so the next things happens fluidly when the first is done.
					Typically, you will want a few different screens (e.g. main menu, the main view etc.). On each screen the user interface is completely different.
					Some screens have many elements (e.g. units on a battlefield) that are created and destroyed dynamically via complex logic.
					I hypothesise that static dataflow a la FRP is not what you want to use to build such an application, as the high amount of dynamism is a bad fit. However,
					reactive extensions observers <em>are</em> what you want, as they have the nice chainable temporal characteristics but without the straight jacket of static dataflow.
				As a consequence though, that you have to take control of how values update through the dataflow graph.</p>
				<p>The composable building block of Animaxe is an Animation. An animation does something with the drawing context. An animation can do something indefinitely, for example this draws a red square forever:</p>
				<pre><code> foreverRedSquare() {
    <span class="hljs-keyword">return</span> Ax 
        .fillStyle = <span class="hljs-string">"red"</span>;
        .fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
 }
</code></pre><p>But an animation can also have a finite duration. You can turn an infinite animation into a finite animation using <code>take(&lt;n&gt;)</code>:</p>
				<pre><code>  redSquareFor2Frames() {<span class="hljs-keyword">return</span> foreverRedSquare().take(<span class="hljs-number">2</span>);}
</code></pre><p>You can chain animations temporally using <code>.then</code>, which creates a new animation from the the temporal concatenation.</p>
				<pre><code>  redThenGreenSquareFor4Frames<span class="hljs-literal">()</span> {return redSquareFor2Frames<span class="hljs-literal">()</span>.<span class="hljs-keyword">then</span>(greenSquareFor2Frames<span class="hljs-literal">()</span>);}
</code></pre><p>You can create an infinite length animation from a limited duration animation by using <code>.loop()</code>, which just repeatedly sequences the same animation end-to-end</p>
				<pre><code> foreverRedAndGreenSquare() {<span class="hljs-keyword">return</span> Ax.<span class="hljs-keyword">loop</span>(redThenGreenSquareFor4Frames())<span class="hljs-comment">;}</span>
</code></pre><p>These animation operators are the defining characteristics of Animaxe,
					which internally resolve around using Rx&#39;s onCompleted semantic to dynamically change the dataflow graph.
				I believe these dynamic operators are hard to implement in traditional* FRP (see also <a href="https://blogs.janestreet.com/breaking-down-frp/">https://blogs.janestreet.com/breaking-down-frp/</a>). The dynamic operators so far in Animaxe are:-</p>
				<ul>
					<li>parallel (play multiple animations at the same time)</li>
					<li>clone (specialised version of parallel which plays the same animation multiple times)</li>
					<li>emit (spawn a new animation every frame)</li>
					<li>take (limit the temporal duration of an animation)</li>
					<li>then (concatinate animations temporally)</li>
					<li>pipe (pass the context of one animation into another)</li>
					<li>loop (create an infinite duration animation by repeatedly resequencing)</li>
					<li><p>.if .elif .else (switch an animation based on reevaluated conditionals)</p>
					</li>
					<li><p>note though, arrowized FRP seems to solve a similar problem.</p>
					</li>
				</ul>
				<h2 id="examples">Examples</h2>
				<p>Example 1 - Basic animation compositions
				(<a href="./test/example1.ts">source</a>)</p>
				<p><img src="./images/example1.gif?raw=true" alt="Example1"></p>
				<p>Example 2 - Skewing time and dynamic colors
				(<a href="./test/example2.ts">source</a>)</p>
				<p><img src="./images/example2.gif?raw=true" alt="Example2"></p>
				<p>Example 3 - Particles
					(<a href="./test/example3.ts">source</a>)
				(<a href="http://codepen.io/tomlarkworthy/pen/jbmVWO?editors=001">edit on Codepen</a>)</p>
				<p><img src="./images/example3.gif?raw=true" alt="Example3"></p>
				<p>Example 4 - Glow filter
				(<a href="./test/example4.ts">source</a>)</p>
				<p><img src="./images/example4.gif?raw=true" alt="Example4"></p>
				<p>Example 5 - UI Button
					(<a href="./test/example5.ts">source</a>)
				(<a href="http://codepen.io/tomlarkworthy/pen/yYxwga?editors=001">edit on Codepen</a>)</p>
				<p><img src="./images/example5.gif?raw=true" alt="Example5"></p>
				<p>Example 6 - UI Slider
					(<a href="./test/example6.ts">source</a>)
				(<a href="http://codepen.io/tomlarkworthy/pen/ojaGZz?editors=001">edit on Codepen</a>)</p>
				<p><img src="./images/example6.gif?raw=true" alt="Example6"></p>
				<p>We have some examples in the test directory written in Typescript.
					You can use the babel preprocessor within Codepen quite well. Although it borks on some of the typescript syntax,
				if anyone knows a good online Typescript editor that can read type definition files I would love to hear.</p>
				<h2 id="using-on-web">Using on web</h2>
				<p>Animaxe is written with commonjs modules, so for web distribution its webpacked.
				So an alternative set of libraries (compared to node.js) should be used in script tags</p>
				<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"rx/dist/rx.all.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"animaxe/dist/ax.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- exposes "var Ax" --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"animaxe/dist/px.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- exposes "var Parameter" --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"animaxe/dist/hx.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- exposes "var helper" --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"animaxe/dist/ex.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- exposes "var events" --&gt;</span>
</code></pre><h2 id="using-with-typescript-in-node-js">Using with Typescript in node.js</h2>
				<p>Animations are rendered using canvas. Its a bitch to install. You should require() within a Typescript environment</p>
				<pre><code><span class="hljs-keyword">import</span> <span class="hljs-literal">Rx</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"rx"</span>);
<span class="hljs-keyword">import</span> Ax = <span class="hljs-keyword">require</span>(<span class="hljs-string">"animaxe/dist/animaxe"</span>);
<span class="hljs-keyword">import</span> events = <span class="hljs-keyword">require</span>(<span class="hljs-string">"animaxe/dist/events"</span>);
<span class="hljs-keyword">import</span> Parameter = <span class="hljs-keyword">require</span>(<span class="hljs-string">"animaxe/dist/parameter"</span>);
<span class="hljs-keyword">import</span> helper = <span class="hljs-keyword">require</span>(<span class="hljs-string">"animaxe/dist/helper"</span>);
</code></pre><p>The definitions are also in dist.</p>
				<h2 id="api">API</h2>
				<p>Its being changed a lot but it&#39;s <a href="https://animaxe.firebaseapp.com/">here</a></p>
				<h1 id="todos">TODOS</h1>
				<h2 id="packaging">Packaging</h2>
				<ul>
					<li>I don&#39;t like the webpack names have to be different</li>
					<li>Test npm integration...</li>
					<li>ES6 modules? Can we make the packaging equivalent? Maybe jsut a browser &amp; and node.js directory structure?</li>
					<li>Change focus, Web should be 1st class, and node should be the one with janky scripts around it</li>
				</ul>
				<h2 id="glow">Glow</h2>
				<ul>
					<li>different distance exponents are interesting</li>
					<li>think about alpha over existing backgrounds<ul>
							<li>improve effeciency by calculating the glow envelope when applying it</li>
						</ul>
					</li>
				</ul>
				<h2 id="features">Features</h2>
				<ul>
					<li>.if .elif .else .fi e.g. .if(BoolArg, <anim>).fi().fill()</li>
					<li>Reflection</li>
					<li>L-systems (fold?)</li>
					<li>Perlin noise</li>
					<li>simulate a lazer show, XY parametric functions (Lissajous curves), intergrate with ODE solve</li>
				</ul>
				<h2 id="engineering">Engineering</h2>
				<ul>
					<li>figure out why example3 cannot have move than 1000 particles without a stack overflow</li>
					<li>remove randomness (example 3) with a random seed (seed random with animation seed?) for repeatabe tests</li>
					<li>replace paralel with its own internal animator OR make parallel the only option</li>
					<li>check for memory leaks from recursive closures.</li>
				</ul>
				<h2 id="refactors">Refactors</h2>
				<ul>
					<li>change order of playExample parameters</li>
					<li>(done) Parameter to go in own module, params chained to make value read left to right</li>
					<li>(done) Parameter.rnd().first()        // maybe we should just make it pure by seeding the rnd by epock or tree position?</li>
					<li>(done) Parameter.rnd().map(x =&gt; x*x)</li>
					<li>(done) Ax.Parameter() for construction</li>
					<li>(done) Make methods chain as an alternative to wrapping, e.g. Ax.move(...).velocity(...)</li>
					<li>(done) add .pipe(animation) so users can chain themselves</li>
					<li>(partial) align names of methods with canvas context name, e.g. fillStyle(Color)<ul>
							<li>finish that API!</li>
							<li>withinClip, withinTx, (done) withinPath</li>
							<li>createLinearGradient, createPattern(), createRadialGradient(), addColorStop(), isPointInPath(), measureText(), drawImage()</li>
							<li>save() restore()</li>
						</ul>
					</li>
					<li>maybe put context methods in their own namespace if possible? (long term goal)</li>
					<li>consider hiding time from Animation? It should only be used in params</li>
					<li>simplifying closure situation? Maybe handle params internally through DI?</li>
					<li>the way the tick is passed on in Animator is ugly</li>
					<li>All the complex methods are implemented badly, then, emit, parallel. Maybe state machines? (if else is quite good)</li>
					<li>Maybe we can make Parameter and Rx.JS, in the init, we pass a clock Behaviour, and use combineLatest within the animations to merge</li>
				</ul>
				<h2 id="api-documentation">API documentation</h2>
				<ul>
					<li>method chaining</li>
					<li>lifecycle</li>
					<li>making your own Animation</li>
					<li>making your own Parameters</li>
					<li>overriding the prototype</li>
					<li>using .pipe()</li>
					<li>example of switching from the canvas API to a linear chain</li>
					<li>how a new chain resets the context</li>
					<li>using <a href="https://github.com/anthonydugois/svg-path-builder">https://github.com/anthonydugois/svg-path-builder</a></li>
				</ul>
				<h2 id="website">website</h2>
				<ul>
					<li>npm</li>
				</ul>
				<h2 id="code-pen-example">Code pen example</h2>
				<ul>
					<li>sync with codepen automatically</li>
				</ul>
				<h2 id="ui-controls">UI controls</h2>
				<ul>
					<li>slider<ul>
							<li>todo: let the user pass in the source of truth, and through a callback, let the user connect the value change to the source of truth
							this will allow min/max without hardcoding logic in the basic slider</li>
							<li></li>
						</ul>
					</li>
					<li>(done) button</li>
					<li>knob</li>
					<li>(done) Default mouse behaviour.</li>
					<li>(done) relative positions and transformation aware</li>
					<li>As we need global event listeners (e.g. slider needs to listen to mouse moves after the mouse has left the component)
					we should have a global mouse listener implemented with RxJS which local listeners map over, instead of the ropey array thing we have for global events</li>
				</ul>
				<h2 id="random-ideas">Random IDEAS</h2>
				<ul>
					<li>PacMan</li>
					<li>mouse input, tailing glow (remember to tween between rapid movements)</li>
					<li>prerendering an animation for fast playback</li>
					<li>SVG path parser for withinPath</li>
				</ul>
				<h2 id="todo">TODO</h2>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_animaxe_.html">"animaxe"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_events_.html">"events"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_experiment_.html">"experiment"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_helper_.html">"helper"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_parameter_.html">"parameter"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.io" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>